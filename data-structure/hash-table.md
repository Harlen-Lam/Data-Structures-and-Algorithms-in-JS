# 哈希表
`哈希表是一种非常重要的数据结构,几乎所有的编程语言都有直接或者间接的应用这种数据结构.`
- [哈希表理论目录](#哈希表理论目录)
- [哈希表实现目录](#哈希表实现目录)

## 哈希表理论目录
### 一.认识哈希表
- [哈希表介绍](#哈希表介绍)
- [体会哈希表](#体会哈希表)
- [字母转数字](#字母转数字)
- [认识哈希化](#认识哈希化)
### 二.地址的冲突
- [什么是冲突](#什么是冲突)
- [链地址法](#链地址法)
- [开放地址法](#开放地址法)
- [线性探测](#线性探测)
- [二次探测](#二次探测)
- [再哈希法](#再哈希法)
### 三.哈希化的效率
- [装填因子](#装填因子)
- [开放地址法](#开放地址法-1)
- [线性探测](#线性探测-1)
- [二次探测和再哈希](#二次探测和再哈希)
- [链地址法](#链地址法-1)
- [效率的结论](#效率的结论)

## 哈希表实现目录
### 四.哈希函数
- [快速的计算](#快速的计算)
- [均匀的分布](#均匀的分布)
- [哈希函数实现](#哈希函数实现)
### 五.哈希表
- [创建哈希表](#创建哈希表)
- [插入&修改数据](#插入修改数据)
- [获取数据](#获取数据)
- [删除数据](#删除数据)
- [其他方法](#其他方法)
- [哈希表测试](#哈希表测试)
### 六.哈希表扩容
- [哈希表扩容的思想](#哈希表扩容的思想)
- [哈希表扩容的实现](#哈希表扩容的实现)
### 七.容量质数
- [判断质数](#判断质数)
- [扩容的质数](#扩容的质数)
### 八.完整代码
- [哈希表完整代码](#哈希表完整代码)

## 一.认识哈希表
### 哈希表介绍
- 哈希表通常是基于**数组**进行实现的, 但是相对于数组, 它也很多的优势:
  - 它可以提供**非常快速**的插入-删除-查找操作
  - 无论多少数据, 插入和删除值需要接近常量的时间: 即O(1)的时间级. 实际上, 只需要几个机器指令即可
  - 哈希表的速度比树还要快, 基本可以瞬间查找到想要的元素
  - 哈希表相对于树来说编码要容易很多.
- 哈希表相对于数组的一些不足:
  - 哈希表中的数据是**没有顺序**的, 所以不能以一种固定的方式(比如从小到大)来遍历其中的元素.
  - 通常情况下, 哈希表中的key是**不允许重复**的, 不能放置相同的key, 用于保存不同的元素.
- 那么, 哈希表到底是什么呢?
  - 它的结构就是数组, 但是它神奇的地方在于对下标值的一种变换, 这种变换我们可以称之为哈希函数, 通过哈希函数可以获取到HashCode.
### 体会哈希表
- 案例一: 公司使用一种数据结构来保存所有员工
  - 案例介绍:
    - 假如一家公司有1000个员工, 现在我们需要将这些员工的信息使用某种数据结构来保存起来
    - 你会采用什么数据结构呢?
  - 方案一: 数组
    - 一种方案是按照顺序将所有的员工依次存入一个长度为1000的数组中. 每个员工的信息都保存在数组的某个位置上.
    - 但是我们要查看某个具体员工的信息怎么办呢? 一个个找吗? 不太好找.
    - 数组最大的优势是什么? 通过下标值去获取信息.
    - 所以为了可以通过数组快速定位到某个员工, 最好给员工信息中添加一个员工编号, 而编号对应的就是员工的下标值.
    - 当查找某个员工的信息时, 通过员工编号可以快速定位到员工的信息位置.
  - 方案二: 链表
    - 链表对应插入和删除数据有一定的优势.
    - 但是对于获取员工的信息, 每次都必须从头遍历到尾, 这种方式显然不是特别适合我们这里.
  - 最终方案:
    - 这样看最终方案似乎就是数组了. 但是数组还是有缺点, 什么缺点呢?
    - 假如我想查看一下张三这位员工的信息, 但是我不知道张三的员工编号, 你怎么办呢?
    - 当然, 你说我可以问他. 但是你每查找一个员工都是问一下这个员工的编号吗? 不合适.
    - 能不能有一种办法, 让张三的名字和它的员工编号产生直接的关系呢?
    - 也就是通过张三这个名字, 我就能获取到它的索引值, 而再通过索引值我就能获取到张三的信息呢?
    - 这样的方案已经存在了, 就是使用哈希函数, 让某个key的信息和索引值对应起来.
- 案例二: 设计一个数据结构, 保存联系人和电话.
  - 有没有一种方案, 可以将联系人和数组的下标值对应呢?
  - 那么我们就可以让联系人的名字作为下标值, 来获取这个联系人对应的电话.
  - 但是联系人的名字(字符串)可以作为下标值吗? 当然不可以.
  - 所以你需要一种方案将字符串转成下标值.
- 案例三: 使用一种数据结构存储单词信息, 比如有50000个单词. 找到单词后每个单词有自己的翻译&读音&应用等等
  - 有没有一种方案, 可以将单词转成数组的下标值呢?
  - 如果单词转成数组的下标, 那么以后我们要查找某个单词的信息, 直接按照下标值一步即可访问到想要的元素.
- 案例四: 高级语言的编译器
  - 事实上哈希表还有另外一个非常重要的应用场景, 就是高级语言的编译器.
  - 它通常用哈希表来保留符号表.
  - 符号表记录了程序员声明的所有变量和函数名, 以及它们在内存中的地址.
  - 程序需要快速的访问这些名字, 所以哈希表是理想的实现方式.
### 字母转数字
- 但是, 怎样才能将一个单词转成数组的下标值呢?
  - 单词转下标值, 其实就是字母转数字, 怎么转?
- 现在我们需要设计一种方案, 可以将单词转成合适的下标:
  - 其实计算机中有很多的编码方案就是用数字代替单词的字符.
  - 比如ASCII编码: a是97, b是98, 依次类推122代表z
  - 我们也可以设计一个自己的编码系统, 比如a是1, b是2, c是3, 依次类推, z是26. 当然我们可以加上空格用0代替, 就是27个字符(不考虑大写问题)
  - 但是, 有了编码系统后, 一个单词如何转成数字呢?
- 方案一: 数字相加
  - 一个转换单词的简单方案就是把单词每个字符的编码求和.
  - 例如单词cats转成数字: 3+1+20+19=43, 那么43就作为cats单词的下标存在数组中.
  - 问题: 按照这种方案有一个很明显的问题就是很多单词最终的下标可能都是43.
  - 比如was/tin/give/tend/moan/tick等等.
  - 我们知道数组中一个下标值位置只能存储一个数据, 如果存入后来的数据, 必然会造成数据的覆盖.
  - 一个下标存储这么多单词显然是不合理的.
- 方案二: 幂的连乘
  - 现在, 我们想通过一种算法, 让cats转成数字后不那么普通. 数字相加的方案就有些过于普通了.
  - 有一种方案就是使用**幂的连乘**, 什么是幂的连乘呢?
  - 其实我们平时使用的大于10的数字, 可以用一种幂的连乘来表示它的唯一性:比如: 7654 = 7*10³+6*10²+5*10+4
  - 我们的单词也可以使用这种方案来表示: 比如cats = 3*27³+1*27²+20*27+17= 60337
  - 这样得到的数字可以几乎保证它的唯一性, 不会和别的单词重复.
  - 问题: 如果一个单词是zzzzzzzzzz(一般英文单词不会超过10个字符). 那么得到的数字超过7000000000000. 数组可以表示这么大的下标值吗?
  - 而且就算能创建这么大的数组, 事实上有很多是无效的单词. 创建这么大的数组是没有意义的.  
    ![image](https://github.com/user-attachments/assets/0c84213a-0514-4631-881a-f281f4dc9948)
- 两种方案总结:
  - 第一种方案(把数字相加求和)产生的数组下标太少.
  - 第二种方案(与27的幂相乘求和)产生的数组下标又太多.
### 认识哈希化
- 现在需要一种压缩方法, 把幂的连乘方案系统中得到的巨大整数范围压缩到可接受的数组范围中.
- 对于英文词典, 多大的数组才合适呢?
  - 如果只有50000个单词, 可能会定义一个长度为50000的数组.
  - 但是实际情况中, 往往需要更大的空间来存储这些单词. 因为我们不能保存单词会映射到每一个位置. (比如两倍的大小: 100000).
- 如何压缩呢?
  - 现在, 就找一种方法, 把0到超过7000000000000的范围, 压缩为从0到100000.
  - 有一种简单的方法就是使用**取余操作符**, 它的作用是得到一个数被另外一个数整除后的余数..
- 取余操作的实现:
  - 假设把从0~199的数字, 比如使用largeNumber代表, 压缩为从0到9的数字, 比如使用smallRange代表.
  - 下标值的结果: index = largeNumber % smallRange;
  - 当一个数被10整除时, 余数一定在0~9之间;
  - 比如13%10=3, 157%10=7.
  - 当然, 这中间还是会有重复, 不过重复的数量明显变小了. 因为我们的数组是100000, 而只有50000个单词.
  - 就好比, 你在0~199中间选取5个数字, 放在这个长度为10的数组中, 也会重复, 但是重复的概率非常小. (后面我们会讲到真的发生重复了应该怎么解决)
- 了解了上面的内容, 相信你应该懂了哈希表的原理了, 我们来看看几个概念:
  - **哈希化**: 将大数字转化成数组范围内下标的过程, 我们就称之为哈希化.
  - **哈希函数**: 通常我们会将单词转成大数字, 大数字在进行哈希化的代码实现放在一个函数中, 这个函数我们成为哈希函数.
  - **哈希表**: 最终将数据插入到的这个数组, 我们就称之为是一个哈希表.
## 二.地址的冲突
### 什么是冲突
- 两个数据通过哈希函数得到的数组下标是相同的，这就是冲突.  
  ![image](https://github.com/user-attachments/assets/72d09e32-b10c-4828-9394-c69efe0dee78)
- 如何解决这种冲突呢? 常见的情况有两种方案.
  - 链地址法.
  - 开放地址法.
### 链地址法
- 链地址法是一种比较常见的解决冲突的方案.(也称为**拉链法**)
- 链地址法图片  
  ![image](https://github.com/user-attachments/assets/ef4831f2-ab46-4973-b98c-26e03872070f)
- 图片解析:
  - 从图片中我们可以看出, 链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据, 而是一个链条.
  - 这个链条使用什么数据结构呢? 常见的是**数组**或者**链表**.
  - 比如链表, 也就是每个数组单元中存储着一个链表. 一旦发现重复, 将重复的元素插入到链表的首端或者末端即可.
  - 当查询时, 先根据哈希化后的下标值找到对应的位置, 再取出链表, 依次查询所寻找的数据.
- 数组还是链表呢?
  - 数组或者链表在这里其实都可以, 效率上也差不多.
  - 因为根据哈希化的index找出这个数组或者链表时, 通常就会使用线性查找, 这个时候数组和链表的效率是差不多的.
  - 当然在某些实现中, 会将新插入的数据放在数组或者链表的最前面, 因为新插入的数据被取出的可能性更大.
  - 这种情况最好采用链表, 因为数组在首位插入数据是需要所有其他项后移的, 链表就没有这样的问题.
  - 当然, 我觉得这个也看业务需求, 不见得新的数据就访问次数会更多: 比如我们微信新添加的好友, 可能是刚认识的, 联系的频率不见得比我们的老朋友更多, 甚至新加的只是聊一两句.
  - 所以, 这里个人觉得选择数组或者链表都是可以的.
### 开放地址法
- 开放地址法的主要工作方式是寻找空白的单元格来添加重复的数据.
- 开放地址法图解  
  ![image](https://github.com/user-attachments/assets/261c51f1-c69b-4f2a-b3f7-601242e6b446)
- 图片解析:
  - 从图片的文字中我们可以了解到, 开放地址法其实就是要寻找空白的位置来放置冲突的数据项.
  - 但是探索这个位置的方式不同, 有三种方法:
    - 线性探测
    - 二次探测
    - 再哈希法
### 线性探测
- 线性探测非常好理解: 线性的查找空白的单元.
- 插入的32:
  - 经过哈希化得到的index=2, 但是在插入的时候, 发现该位置已经有了82. 怎么办呢?
  - 线性探测就是从index位置+1开始一点点查找合适的位置来放置32, 什么是合适的位置呢?
  - 空的位置就是合适的位置, 在我们上面的例子中就是index=3的位置, 这个时候32就会放在该位置.
- 查询32呢?
  - 查询32和插入32比较相似.
  - 首先经过哈希化得到index=2, 比如2的位置结果和查询的数值是否相同, 相同那么就直接返回.
  - 不相同呢? 线性查找, 从index位置+1开始查找和32一样的.
  - 这里有一个特别需要注意的地方: 如果32的位置我们之前没有插入, 是否将整个哈希表查询一遍来确定32存不存在吗?
  - 当然不是, 查询过程有一个约定, 就是查询到**空位置**, 就停止. (因为查询到这里有空位置, 32之前不可能跳过空位置去其他的位置.)
- 删除32呢?
  - 删除操作和插入查询比较类似, 但是也有一个特别注意点.
  - 注意: 删除一个数据项时, 不可以将这个位置下标的内容设置为null, 为什么呢?
  - 因为将它设置为null可能会影响我们之后查询其他操作, 所以通常删除一个位置的数据项时, 我们可以将它进行**特殊处理**(比如设置为-1).
  - 当我们之后看到-1位置的数据项时, 就知道查询时要继续查询, 但是插入时这个位置可以放置数据.
- 线性探测的问题:
  - 线性探测有一个比较严重的问题, 就是**聚集**. 什么是聚集呢?
  - 比如我在没有任何数据的时候, 插入的是22-23-24-25-26, 那么意味着下标值:2-3-4-5-6的位置都有元素. 这种一连串填充单元就叫做聚集.
  - 聚集会影响哈希表的性能, 无论是插入/查询/删除都会影响.
  - 比如我们插入一个32, 会发现连续的单元都不允许我们放置数据, 并且在这个过程中我们需要探索多次.
  - 二次探测可以解决一部分这个问题.
### 二次探测
- 线性探测存在的问题: 就是如果之前的数据是连续插入的, 那么新插入的一个数据可能需要探测很长的距离.
- 二次探测在线性探测的基础上进行了优化:
  - 二次探测主要优化的是**探测时的步长**, 什么意思呢?
  - 线性探测, 我们可以看成是步长为1的探测, 比如从下标值x开始, 那么线性测试就是x+1, x+2, x+3依次探测.
  - 二次探测, 对步长做了优化, 比如从下标值x开始, x+1², x+2², x+3².
  - 这样就可以一次性探测比较长的距离, 来避免那些聚集带来的影响.
- 二次探测的问题:
  - 但是二次探测依然存在问题, 比如我们连续插入的是32-112-82-2-192, 那么它们都是从2这个位置往后进行二次探测.
  - 也就是这种情况下会造成步长不一的一种聚集. 还是会影响效率.
  - 怎么根本解决这个问题呢? 让每个人的步长不一样, 一起来看看再哈希法吧.
### 再哈希法
- 为了消除线性探测和二次探测中无论步长+1还是步长+平方中存在的问题, 还有一种最常用的解决方案: **再哈希法**.
- 再哈希法:
  - 二次探测的算法产生的探测序列步长是固定的: 1, 4, 9, 16, 依次类推.
  - 现在需要一种方法: 产生一种依赖关键字的探测序列, 而不是每个关键字都一样.
  - 那么, 不同的关键字即使映射到相同的数组下标, 也可以使用不同的探测序列.
  - 再哈希法的做法就是: 把关键字用另外一个哈希函数, 再做一次哈希化, 用这次哈希化的结果作为步长.
  - 对于指定的关键字, 步长在整个探测中是不变的, 不过不同的关键字使用不同的步长.
- 第二次哈希化需要具备如下特点:
  - 和第一个哈希函数不同. (不要再使用上一次的哈希函数了, 不然结果还是原来的位置)
  - 不能输出为0(否则, 将没有步长. 每次探测都是原地踏步, 算法就进入了死循环)
- 其实, 我们不用费脑细胞来设计了, 计算机专家已经设计出一种工作很好的**哈希函数**:
  - stepSize = constant - (key % constant)
  - 其中constant是质数, 且小于数组的容量.
  - 例如: stepSize = 5 - (key % 5), 满足需求, 并且结果不可能为0.
## 三.哈希化的效率
```
哈希表中执行插入和搜索操作可以达到O(1)的时间级，如果没有发生冲突，
只需要使用一次哈希函数和数组的引用，就可以插入一个新数据项或找到一个已经存在的数据项。

如果发生冲突，存取时间就依赖后来的探测长度。
一个单独的查找或插入时间与探测的长度成正比，这里还要加上哈希函数的常量时间。

平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度也越来越长。

随着填装因子变大，效率下降的情况，在开放地址法方案中比链地址法更严重,
所以我们来对比一下他们的效率, 再决定我们选取的方案.
```
### 装填因子
- 在分析效率之前, 我们先了解一个概念: 装填因子.
- **装填因子**表示当前哈希表中已经包含的数据项和整个哈希表长度的比值.
  - 装填因子 = 总数据项 / 哈希表长度.
- 开放地址法的装填因子最大是多少呢? 1, 因为它必须寻找到空白的单元才能将元素放入.
- 链地址法的装填因子呢? 可以大于1, 因为拉链法可以无限的延伸下去, 只要你愿意. (当然后面效率就变低了)
### 开放地址法
- 我们来一个个认识一下开放地址法中每种方案的效率.
### 线性探测
- 下面的等式显示了线性探测时，探测序列(P)和填装因子(L)的关系
  - 对成功的查找: P = (1+1/(1-L))/2
  - 对不成功的查找: P=(1+1/(1-L)^2)/2
- 公式来自于Knuth(算法分析领域的专家, 现代计算机的先驱人物), 这些公式的推导自己去看了一下, 确实有些繁琐, 这里不再给出推导过程, 仅仅说明它的效率.
- 图解算法的效率:  
  ![image](https://github.com/user-attachments/assets/a743fe69-2d4a-480e-a839-b4cc878f3ce3)
- 图片解析:
  - 当填装因子是1/2时，成功的搜索需要1.5次比较，不成功的搜索需要2.5次
  - 当填装因子为2/3时，分别需要2.0次和5.0次比较
  - 如果填装因子更大，比较次数会非常大。
  - 应该使填装因子保持在2/3以下，最好在1/2以下，另一方面，填装因子越低，对于给定数量的数据项，就需要越多的空间。
  - 实际情况中，最好的填装因子取决于**存储效率**和**速度**之间的平衡，随着填装因子变小，存储效率下降，而速度上升。
### 二次探测和再哈希
- 二次探测和再哈希法的性能相当。它们的性能比线性探测略好。
  - 对成功的搜索，公式是: -log2(1 - loadFactor) / loadFactor
  - 对于不成功的搜搜, 公式是: 1 / (1-loadFactor)
- 对应的图:  
  ![image](https://github.com/user-attachments/assets/fa07b35d-d5b6-4416-8e9f-6d7ef33275ef)
- 图片解析:
  - 当填装因子是0.5时，成功和不成的查找平均需要2次比较
  - 当填装因子为2/3时，分别需要2.37和3.0次比较
  - 当填装因子为0.8时，分别需要2.9和5.0次
  - 因此对于较高的填装因子，对比线性探测，二次探测和再哈希法还是可以忍受的。
### 链地址法
- 链地址法的效率分析有些不同, 一般来说比开放地址法简单. 我们来分析一下这个公式应该是怎么样的.
  - 假如哈希表包含arraySize个数据项, 每个数据项有一个链表, 在表中一共包含N个数据项.
  - 那么, 平均起来每个链表有多少个数据项呢? 非常简单, N / arraySize.
  - 有没有发现这个公式有点眼熟? 其实就是装填因子.
- OK, 那么我们现在就可以求出查找成功和不成功的次数了
  - 成功可能只需要查找链表的一半即可: 1 + loadFactor/2
  - 不成功呢? 可能需要将整个链表查询完才知道不成功: 1 + loadFactor.
- 对应的图  
  ![image](https://github.com/user-attachments/assets/306b64d0-2909-4831-9213-d0404742cd0a)
### 效率的结论
- 经过上面的比较我们可以发现, 链地址法相对来说效率是**好于**开放地址法的.
- 所以在真实开发中, 使用链地址法的情况较多, 因为它不会因为添加了某元素后性能急剧下降.
  - 比如在Java的HashMap中使用的就是链地址法.

## 四.哈希函数
`哈希函数应该具备哪些优点.`
### 快速的计算
- 好的哈希函数应该尽可能让计算的过程变得简单, 应该可以快速计算出结果.
  - 哈希表的主要优点是它的**速度**, 所以在速度上不能满足, 那么就达不到设计的目的了.
  - 提高速度的一个办法就是让哈希函数中尽量有少的乘法和除法. 因为它们的性能是比较低的.
- 在前面, 我们计算哈希值的时候使用的方式
  - cats = 3*27³+1*27²+20*27+17= 60337
  - 这种方式是直观的计算结果, 那么这种计算方式会进行几次乘法几次加法呢? 当然, 我们可能不止4项, 可能有更多项
  - 我们抽象一下, 这个表达式其实是一个多项式: a(n)x<sup>n</sup>+a(n-1)x<sup>(n-1)</sup>+…+a(1)x+a(0)
  - 现在问题就变成了多项式有多少次乘法和加法:
    - 乘法次数: n＋(n－1)＋…＋1＝n(n+1)/2
    - 加法次数: n次
- 多项式的优化: 霍纳法则
  - 解决这类求值问题的高效算法――霍纳法则。在中国，霍纳法则也被称为秦九韶算法。
  - 通过如下变换我们可以得到一种快得多的算法，即Pn(x) = a(n)x<sup>n</sup>+a(n-1)x<sup>(n-1)</sup>+…+a(1)x+a(0) = ((…(((a(n)x +a(n－1))x+a(n－2))x+ a(n－3))…)x+a(1)x+a(0)，这种求值的安排我们称为霍纳法则。
  - 变换后, 我们需要多少次乘法, 多少次加法呢?
    - 乘法次数: N次
    - 加法次数: N次.
  - 如果使用大O表示时间复杂度的话, 我们直接从O(N²)降到了O(N).
### 均匀的分布
- 均匀的分布
  - 在设计哈希表时, 我们已经有办法处理映射到相同下标值的情况: 链地址法或者开放地址法.
  - 但是, 为了提供效率, 最好的情况还是让数据在哈希表中均匀分布.
  - 因此, 我们需要在使用常量的地方, 尽量使用质数.
  - 哪些地方我们会使用到常量呢?
- 质数的使用:
  - 哈希表的长度.
  - N次幂的底数(我们之前使用的是27)
- 哈希表的长度使用质数:
  - 这个在链地址法中事实上重要性不是特别明显, 明显的是在开放地址法中的**再哈希法**中.
  - 再哈希法中质数的重要性:
    - 假设表的容量不是质数, 例如: 表长为15(下标值0~14)
    - 有一个特定关键字映射到0, 步长为5. 探测序列是多少呢?
    - 0 - 5 - 10 - 0 - 5 - 10, 依次类推, 循环下去.
    - 算法只尝试三个单元, 如果这三个单元已经有了数据, 那么会一直循环下去, 直到程序崩溃.
    - 如果容量是一个质数, 比如13. 探测序列是多少呢?
    - 0 - 5 - 10 - 2 - 7 - 12 - 4 - 9 - 1 - 6 - 11 - 3, 一直这样下去.
    - 不仅不会产生循环, 而且可以让数据在哈希表中更加均匀的分布.
  - 链地址法中质数没有那么重要, 甚至在Java中故意是2的N次幂
    - Java中的哈希表采用的是链地址法.
    - HashMap的初始长度是16, 每次自动扩展(我们还没有聊到扩展的话题), 长度必须是2的次幂.
    - 这是为了服务于从Key映射到index的算法.
    - HashMap中为了提高效率, 采用了**位运算**的方式.
      - HashMap中index的计算公式: **index = HashCode（Key） & （Length - 1）**
      - 比如计算book的hashcode，结果为十进制的3029737，二进制的10 1110 0011 1010 1110 1001
      - 假定HashMap长度是默认的16，计算Length-1的结果为十进制的15，二进制的1111
      - 把以上两个结果做**与运算**，101110001110101110 1001 & 1111 = 1001，十进制是9，所以 index=9
      - 这样的方式相对于取模来说性能是高的, 因为计算机更容易计算二进制的数据.
    - 但是, 我个人(coderwhy)发现JavaScript中进行较大数据的位运算时会出问题, 所以代码实现中还是使用了**取模**.
- N次幂的底数, 使用质数:
  - 这里采用质数的原因是为了产生的数据不按照某种规律递增.
  - 比如我们这里有一组数据是按照4进行递增的: 0 4 8 12 16, 将其映射到成都为8的哈希表中.
  - 它们的位置是多少呢? 0 - 4 - 0 - 4, 依次类推.
  - 如果我们哈希表本身不是质数, 而我们递增的数量可以使用质数, 比如5, 那么 0 5 10 15 20
  - 它们的位置是多少呢? 0 - 5 - 2 - 7 - 4, 依次类推. 也可以尽量让数据均匀的分布.
  - 我们之前使用的是27, 这次可以使用一个接近的数, 比如31/37/41等等. 一个比较常用的数是37.
### 哈希函数实现
- 哈希函数的实现
  ```
  function hashFunc(str, max) {
      // 1.初始化hashCode的值
      var hashCode = 0
  
      // 2.霍纳算法, 来计算hashCode的数值
      // 使用37作为N次幂的底数
      // str.charCodeAt用于获取字符串中指定位置的字符的 Unicode 编码值。
      for (var i = 0; i < str.length; i++) {
          hashCode = 37 * hashCode + str.charCodeAt(i)
      }
  
      // 3.取模运算
      hashCode = hashCode % max
      return hashCode
  }
  ```
- 代码测试
  ```
  alert(hashFunc("abc", 7)) // 4
  alert(hashFunc("cba", 7)) // 3
  alert(hashFunc("nba", 7)) // 5
  alert(hashFunc("mba", 7)) // 1
  ```
## 五.哈希表
```
我们这里采用链地址法来实现哈希表:
  实现的哈希表(基于storage的数组)每个index对应的是一个数组(bucket).
  (当然基于链表也可以.)

  bucket中存放什么呢? 我们最好将key和value都放进去,我们继续使用一个数组.
  (其实其他语言使用元组更好)
  
  最终我们的哈希表的数据格式是这样:
  [
      [ [k,v], [k,v], [k,v] ] ,
      [ [k,v], [k,v] ],
      [ [k,v] ]
  ]
```
### 创建哈希表
- 创建一个哈希表的类: HashTable
  ```
  // 创建HashTable构造函数
  function HashTable() {
      // 定义属性
      this.storage = []  // 数组，用于存放相关的元素
      this.count = 0    // 存在数据的总个数
      this.limit = 8    // 标记数组storage一共可以存放多少个元素
  
      // 定义相关方法
      // 哈希函数
      HashTable.prototype.hashFunc = function(str, max) {
          // 1.初始化hashCode的值
          var hashCode = 0
  
          // 2.霍纳算法, 来计算hashCode的数值
          for (var i = 0; i < str.length; i++) {
              hashCode = 37 * hashCode + str.charCodeAt(i)
          }
        
          // 3.取模运算
          hashCode = hashCode % max
          return hashCode
      }
  }
  ```
### 插入&修改数据
- put方法
  ```
  // 插入数据方法
  HashTable.prototype.put = function (key, value) {
      // 1.获取key对应的index
      var index = this.hashFunc(key, this.limit)
  
      // 2.取出数组(也可以使用链表)
      var bucket = this.storage[index]
  
      // 3.判断这个数组是否存在
      if (bucket === undefined) {
          // 3.1创建桶
          bucket = []
          this.storage[index] = bucket
      }
      alert(bucket)
      
      // 4.判断是新增还是修改原来的值.
      var override = false
      for (var i = 0; i < bucket.length; i++) {
          var tuple = bucket[i]
          if (tuple[0] === key) {
              tuple[1] = value
              override = true
          }
      }
      
      // 5.如果是新增, 前一步没有覆盖
      if (!override) {
          bucket.push([key, value])
          this.count++
      }
  }
  ```
### 获取数据
- get方法
  ```
  // 获取存放的数据
  HashTable.prototype.get = function (key) {
      // 1.获取key对应的index
      var index = this.hashFunc(key, this.limit)
  
      // 2.获取对应的bucket
      var bucket = this.storage[index]
  
      // 3.如果bucket为null, 那么说明这个位置没有数据
      if (bucket == null) {
          return null
      }
  
      // 4.有bucket, 判断是否有对应的key
      for (var i = 0; i < bucket.length; i++) {
          var tuple = bucket[i]
          if (tuple[0] === key) {
              return tuple[1]
          }
      }
      
      // 5.没有找到, return null
      return null
  }
  ```
### 删除数据
- remove方法
  ```
  // 删除数据
  HashTable.prototype.remove = function (key) {
      // 1.获取key对应的index
      var index = this.hashFunc(key, this.limit)
      
      // 2.获取对应的bucket
      var bucket = this.storage[index]
      
      // 3.判断同是否为null, 为null则说明没有对应的数据
      if (bucket == null) {
          return null
      }
      
      // 4.遍历bucket, 寻找对应的数据
      for (var i = 0; i < bucket.length; i++) {
          var tuple = bucket[i]
          if (tuple[0] === key) {
              bucket.splice(i, 1)
              this.count--
              return tuple[1]
          }
      }
      
      // 5.来到该位置, 说明没有对应的数据, 那么返回null
      return null
  }
  ```
### 其他方法
- isEmpty方法
  ```
  // isEmpty方法
  HashTable.prototype.isEmpty = function () {
      return this.count == 0
  }
  ```
- size方法
  ```
  // size方法
  HashTable.prototype.size = function () {
      return this.count
  }
  ```
### 哈希表测试
- 测试代码
  ```
  // 测试哈希表
  // 1.创建哈希表
  var ht = new HashTable()
  
  // 2.插入数据
  ht.put("abc", "123")
  ht.put("cba", "321")
  ht.put("nba", "521")
  ht.put("mba", "520")
  
  // 3.获取数据
  alert(ht.get("abc"))  // 123
  ht.put("abc", "111")
  alert(ht.get("abc"))  // 111
  
  // 4.删除数据
  alert(ht.remove("abc"))  // 111
  alert(ht.get("abc"))  // null
  ```
## 六.哈希表扩容
### 哈希表扩容的思想
- 为什么需要扩容?
  - 目前, 我们是将所有的数据项放在长度为8的数组中的.
  - 因为我们使用的是链地址法, loadFactor可以大于1, 所以这个哈希表可以无限制的插入新数据.
  - 但是, 随着数据量的增多, 每一个index对应的bucket会越来越长, 也就造成效率的降低.
  - 所以, 在合适的情况对数组进行扩容. 比如扩容两倍.
- 如何进行扩容?
  - 扩容可以简单的将容量增加大两倍(不是质数吗? 质数的问题后面再讨论)
  - 但是这种情况下, 所有的数据项一定要同时进行修改(重新哈希化, 来获取到不同的位置)
  - 比如hashCode=12的数据项, 在length=8的时候, index=4. 在长度为16的时候呢? index=12.
  - 这是一个耗时的过程, 但是如果数组需要扩容, 那么这个过程是必要的.
- 什么情况下扩容呢?
  - 比较常见的情况是loadFactor>0.75的时候进行扩容.
  - 比如Java的哈希表就是在装填因子大于0.75的时候, 对哈希表进行扩容.
### 哈希表扩容的实现
- 扩容函数实现
  ```
  // 哈希表扩容
  HashTable.prototype.resize = function (newLimit) {
      // 1.保存旧的数组内容
      var oldStorage = this.storage
  
      // 2.重置属性
      this.limit = newLimit
      this.count = 0
      this.storage = []
  
      // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中
      oldStorage.forEach(function (bucket) {
          // 1.bucket为null, 说明这里面没有数据
          if (bucket == null) {
              return
          }
  
          // 2.bucket中有数据, 那么将里面的数据重新哈希化插入
          for (var i = 0; i < bucket.length; i++) {
              var tuple = bucket[i]
              this.put(tuple[0], tuple[1])
          }
      }.bind(this))
  }
  ```
- 在什么时候调用扩容方法呢?
  - 在每次添加完新的数据时, 都进行判断. (也就是put方法中)
- 修改put方法
  ```
  // 插入数据方法
  HashTable.prototype.put = function (key, value) {
      // 1.获取key对应的index
      var index = this.hashFunc(key, this.limit)
  
      // 2.取出数组(也可以使用链表)
      // 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ]  [ [k,v] ] ]
      var bucket = this.storage[index]
  
      // 3.判断这个数组是否存在
      if (bucket === undefined) {
          // 3.1创建桶
          bucket = []
          this.storage[index] = bucket
      }
  
      // 4.判断是新增还是修改原来的值.
      var override = false
      for (var i = 0; i < bucket.length; i++) {
          var tuple = bucket[i]
          if (tuple[0] === key) {
              tuple[1] = value
              override = true
          }
      }
  
      // 5.如果是新增, 前一步没有覆盖
      if (!override) {
          bucket.push([key, value])
          this.count++
          // 判断数组是否扩容，按0.75的装填因子计算
          if (this.count > this.limit * 0.75) {
              this.resize(this.limit * 2)
          }
      }
  }
  ```
- 如果我们不断的删除数据呢?
  - 如果不断的删除数据, 当loadFactor < 0.25的时候, 最好将数量限制在一半.
- 修改remove方法
  ```
  // 删除数据
  HashTable.prototype.remove = function (key) {
      // 1.获取key对应的index
      var index = this.hashFunc(key, this.limit)
  
      // 2.获取对应的bucket
      var bucket = this.storage[index]
  
      // 3.判断同是否为null, 为null则说明没有对应的数据
      if (bucket == null) {
          return null
      }
  
      // 4.遍历bucket, 寻找对应的数据
      for (var i = 0; i < bucket.length; i++) {
          var tuple = bucket[i]
          if (tuple[0] === key) {
              bucket.splice(i, 1)
              this.count--
              
              // 缩小数组的容量
              if (this.limit > 8 && this.count < this.limit * 0.25) {
                  this.resize(Math.floor(this.limit / 2))
              }
          }
          return tuple[1]
      }
  
      // 5.来到该位置, 说明没有对应的数据, 那么返回null
      return null
  }
  ```
## 七.容量质数
`虽然在链地址法中将容量设置为质数, 没有在开放地址法中重要, 但是其实链地址法中质数作为容量也更利于数据的均匀分布.`
### 判断质数
- 我们这里先讨论一个常见的面试题, 判断一个数是质数.
- 质数的特点:
  - 质数也称为素数.
  - 质数表示大于1的自然数中, 只能被1和自己整除的数.
- 算法:
  ```
  function isPrime(num) {
      for (var i = 2; i < num; i++) {
          if (num % i == 0) {
              return false
          }
      }
      return true
  }
  
  // 测试
  alert(isPrime(3)) // true
  alert(isPrime(32)) // false
  alert(isPrime(37)) // true
  ```
- 但是, 这种做法的效率并不高. 为什么呢?
  - 对于每个数n，其实并不需要从2判断到n-1
  - 一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n).
  - 比如16可以被分别. 那么是2\*8, 2小于sqrt(16), 也就是4, 8大于4. 而4\*4都是等于sqrt(n)
  - 所以其实我们遍历到等于sqrt(n)即可
  ```
  function isPrime(num) {
      // 1.获取平方根
      var temp = parseInt(Math.sqrt(num))
  
      // 2.循环判断
      for (var i = 2; i <= temp; i++) {
          if (num % i == 0) {
              return false
          }
      }
      return true
  }
  ```
### 扩容的质数
- 首先, 将初始的limit为8, 改成7
- 前面, 我们有对容量进行扩展, 方式是: 原来的容量 x 2
  - 比如之前的容量是7, 那么扩容后就是14. 14还是一个质数吗?
  - 显然不是, 所以我们还需要一个方法, 来实现一个新的容量为质数的算法.
- 那么我们可以封装获取新的容量的代码(质数)
  ```
  // 判断是否是质数
  HashTable.prototype.isPrime = function (num) {
      var temp = parseInt(Math.sqrt(num))
      // 2.循环判断
      for (var i = 2; i <= temp; i++) {
          if (num % i == 0) {
              return false
          }
      }
      return true
  }
  
  // 获取质数
  HashTable.prototype.getPrime = function (num) {
      while (!isPrime(num)) {
          num++
      }
      return num
  }
  ```
- 修改插入数据的代码
  ```
  // 扩容数组的数量
  if (this.count > this.limit * 0.75) {
      var primeNum = this.getPrime(this.limit * 2)
      this.resize(primeNum)
  }
  ```
- 修改删除数据的代码
  ```
  // 缩小数组的容量
  if (this.limit > 7 && this.count < this.limit * 0.25) {
      var primeNum = this.getPrime(Math.floor(this.limit / 2))
      this.resize(primeNum)
  }
  ```
## 八.完整代码
### 哈希表完整代码
```
// 创建HashTable构造函数
function HashTable() {
    // 定义属性
    this.storage = []
    this.count = 0
    this.limit = 8

    // 定义相关方法
    // 判断是否是质数
    HashTable.prototype.isPrime = function (num) {
        var temp = parseInt(Math.sqrt(num))
        // 2.循环判断
        for (var i = 2; i <= temp; i++) {
            if (num % i == 0) {
                return false
            }
        }
        return true
    }

    // 获取质数
    HashTable.prototype.getPrime = function (num) {
        while (!isPrime(num)) {
            num++
        }
        return num
    }

    // 哈希函数
    HashTable.prototype.hashFunc = function(str, max) {
        // 1.初始化hashCode的值
        var hashCode = 0

        // 2.霍纳算法, 来计算hashCode的数值
        for (var i = 0; i < str.length; i++) {
            hashCode = 37 * hashCode + str.charCodeAt(i)
        }

        // 3.取模运算
        hashCode = hashCode % max
        return hashCode
    }

    // 插入数据方法
    HashTable.prototype.put = function (key, value) {
        // 1.获取key对应的index
        var index = this.hashFunc(key, this.limit)

        // 2.取出数组(也可以使用链表)
        // 数组中放置数据的方式: [[ [k,v], [k,v], [k,v] ] , [ [k,v], [k,v] ]  [ [k,v] ] ]
        var bucket = this.storage[index]

        // 3.判断这个数组是否存在
        if (bucket === undefined) {
            // 3.1创建桶
            bucket = []
            this.storage[index] = bucket
        }

        // 4.判断是新增还是修改原来的值.
        var override = false
        for (var i = 0; i < bucket.length; i++) {
            var tuple = bucket[i]
            if (tuple[0] === key) {
                tuple[1] = value
                override = true
            }
        }

        // 5.如果是新增, 前一步没有覆盖
        if (!override) {
            bucket.push([key, value])
            this.count++

            if (this.count > this.limit * 0.75) {
                var primeNum = this.getPrime(this.limit * 2)
                this.resize(primeNum)
            }
        }
    }

    // 获取存放的数据
    HashTable.prototype.get = function (key) {
        // 1.获取key对应的index
        var index = this.hashFunc(key, this.limit)

        // 2.获取对应的bucket
        var bucket = this.storage[index]

        // 3.如果bucket为null, 那么说明这个位置没有数据
        if (bucket == null) {
            return null
        }

        // 4.有bucket, 判断是否有对应的key
        for (var i = 0; i < bucket.length; i++) {
            var tuple = bucket[i]
            if (tuple[0] === key) {
                return tuple[1]
            }
        }

        // 5.没有找到, return null
        return null
    }

    // 删除数据
    HashTable.prototype.remove = function (key) {
        // 1.获取key对应的index
        var index = this.hashFunc(key, this.limit)

        // 2.获取对应的bucket
        var bucket = this.storage[index]

        // 3.判断同是否为null, 为null则说明没有对应的数据
        if (bucket == null) {
            return null
        }

        // 4.遍历bucket, 寻找对应的数据
        for (var i = 0; i < bucket.length; i++) {
            var tuple = bucket[i]
            if (tuple[0] === key) {
                bucket.splice(i, 1)
                this.count--

                // 缩小数组的容量
                if (this.limit > 7 && this.count < this.limit * 0.25) {
                    var primeNum = this.getPrime(Math.floor(this.limit / 2))
                    this.resize(primeNum)
                }
            }
            return tuple[1]
        }

        // 5.来到该位置, 说明没有对应的数据, 那么返回null
        return null
    }

    // isEmpty方法
    HashTable.prototype.isEmpty = function () {
        return this.count == 0
    }

    // size方法
    HashTable.prototype.size = function () {
        return this.count
    }

    // 哈希表扩容
    HashTable.prototype.resize = function (newLimit) {
        // 1.保存旧的数组内容
        var oldStorage = this.storage

        // 2.重置属性
        this.limit = newLimit
        this.count = 0
        this.storage = []

        // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中
        oldStorage.forEach(function (bucket) {
            // 1.bucket为null, 说明这里面没有数据
            if (bucket == null) {
                return
            }

            // 2.bucket中有数据, 那么将里面的数据重新哈希化插入
            for (var i = 0; i < bucket.length; i++) {
                var tuple = bucket[i]
                this.put(tuple[0], tuple[1])
            }
        }).bind(this)
    }
}
```
