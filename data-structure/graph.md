# 图
`在计算机程序设计中, 图也是一种非常常见的数据结构.`

## 目录
### 一. 图的概念
- [什么是图？](#什么是图)
- [图的术语](#图的术语)
- [现实建模](#现实建模)
### 二.图的表示
- [顶点表示](#顶点表示)
- [邻接矩阵](#邻接矩阵)
- [邻接表](#邻接表)
### 三.图的封装
- [创建图类](#创建图类)
- [添加方法](#添加方法)
- [测试代码](#测试代码)
- [toString](#tostring)

## 一. 图的概念
### 什么是图？
- 图是一种与树有些相似的数据结构.
  - 实际上, 在数学的概念上, 树是图的一种.
  - 人与人之间的关系网、互联网中的网络关系都可以用图来模拟.
- 图通常有什么特点呢?
  - 一组顶点：通常用 V (Vertex) 表示顶点的集合
  - 一组边：通常用 E (Edge) 表示边的集合
    - 边是顶点和顶点之间的连线
    - 边可以是有向的, 也可以是无向的.(比如A --- B, 通常表示无向. A --> B, 通常表示有向)
### 图的术语
- 抽象出来的图  
  ![image](https://github.com/user-attachments/assets/d57dc083-e478-4ac2-a783-1dd3cfdc5b0f)
- 顶点:
  - 顶点刚才我们已经介绍过了, 表示图中的一个结点.
  - 比如地铁站中某个站/多个村庄中的某个村庄/互联网中的某台主机/人际关系中的人.
- 边:
  - 边刚才我们也介绍过了, 表示顶点和顶点之间的连线.
  - 比如地铁站中两个站点之间的直接连线, 就是一个边.
  - 注意: 这里的边不要叫做路径, 路径有其他的概念, 待会儿我们会介绍到.
  - 上面的图中: 0 - 1有一条边, 1 - 2有一条边, 0 - 2没有边.
- 相邻顶点
  - 由一条边连接在一起的顶点称为相邻顶点.
  - 比如0 - 1是相邻的, 0 - 3是相邻的. 0 - 2是不相邻的
- 度:
  - 一个顶点的度是相邻顶点的数量.
  - 比如0顶点和其他两个顶点相连, 0顶点的度是2
  - 比如1顶点和其他四个顶点相连, 1顶点的度是4
- 路径:
  - 路径是顶点v1, v2..., vn的一个连续序列, 比如上图中0 1 5 9就是一条路径.
  - 简单路径: 简单路径要求**不包含**重复的顶点. 比如 0 1 5 9是一条简单路径.
  - 回路: 第一个顶点和最后一个顶点相同的路径称为回路. 比如 0 1 5 6 3 0
- 无向图:
  - 上面的图就是一张无向图, 因为所有的边都没有方向.
  - 比如 0 - 1之间有边, 那么说明这条边可以保证 0 -> 1, 也可以保证 1 -> 0.
- 有向图:
  - 有向图表示的图中的边是有方向的.
  - 比如 0 -> 1, 不能保证一定可以 1 -> 0, 要根据方向来定.
- 无权图和带权图
  - 无权图:
    - 我们上面的图就是一张无权图(边没有携带权重)
    - 我们上面的图中的边是没有任何意义的, 不能说 0 - 1的边, 比4 - 9的边更远或者用的时间更长.
  - 带权图:
    - 带权图表示边有一定的权重.
    - 这里的权重可以是任意你希望表示的数据: 比如距离或者花费的时间或者票价.
- 我们来看一张有向和带权的图
  ![image](https://github.com/user-attachments/assets/d064d117-37f0-4a2f-b2f7-ac9b70db31be)
### 现实建模
- 图可用于对现实中很多的系统建模
  - 对交通流量建模
    - 顶点可以表示街道的十字路口, 边可以表示街道.
    - 加权的边可以表示限速, 车道的数量, 或者街道的距离.
    - 建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道.
  - 对飞机航线建模
    - 航空公司可以用图来为其飞行系统建模.
    - 将每个机场看成顶点, 将经过两个顶点的每条航线看作一条边.
    - 加权的边可以表示从一个机场到另一个机场的航班成本, 或两个机场间的距离.
    - 建模人员可以利用这个系统有效的判断从一个城市到另一个城市的最小航行成本.
## 二.图的表示
`在程序中表示图.`
### 顶点表示
- 顶点的表示相对简单, 我们先讨论顶点的表示.
  - 上面的顶点, 我们抽象成了1 2 3 4, 也可以抽象成A B C D. 在后面的案例中, 我们使用A B C D.
  - 那么这些A B C D我们可以使用一个**数组**来存储起来(存储所有的顶点)
  - 当然, A, B, C, D有可能还表示其他含义的数据(比如村庄的名字), 这个时候, 可以另外创建一个数组, 用于存储对应的其他数据.
- 那么边怎么表示呢?
  - 因为边是两个顶点之间的关系, 所以表示起来会稍微麻烦一些.
  - 下面, 我们具体讨论一下边常见的表示方式.
### 邻接矩阵
- 一种比较常见的表示图的方式: 邻接矩阵.
  - **邻接矩阵**让每个节点和一个整数相关联, 该整数作为数组的下标值.
  - 我们用一个二维数组来表示顶点之间的连接.
- 画图演示:
  ![image](https://github.com/user-attachments/assets/c100f554-44ca-4a15-ab4d-5378d1d51dbe)
- 图片解析:
  - 在二维数组中, 0表示没有连线, 1表示有连线.
  - 通过二维数组, 我们可以很快的找到一个顶点和哪些顶点有连线.(比如A顶点, 只需要遍历第一行即可)
  - 另外, A - A, B - B(也就是顶点到自己的连线), 通常使用0表示.
- 邻接矩阵的问题:
  - 如果是一个无向图, 邻接矩阵展示出来的二维数组, 其实是一个对称图.
    - 也就是A -> D是1的时候, 对称的位置 D -> 1一定也是1.
    - 那么这种情况下会造成空间的浪费, 你有没有办法可以优化呢? 作为一个思考题, 大家可以自行研究一下
    - (也许可以考虑使用半个矩阵?)
  - 邻接矩阵还有一个比较严重的问题就是如果图是一个**稀疏图**
    - 那么矩阵中将存在大量的0, 这意味着我们浪费了计算机存储空间来表示根本不存在的边.
    - 而且即使只有一个边, 我们也必须遍历一行来找出这个边, 浪费很多时间.
### 邻接表
- 另外一种常用的表示图的方式: 邻接表.
  - **邻接表**由图中每个顶点以及和顶点相邻的顶点列表组成.
  - 这个列表有很多中方式来存储: 数组/链表/字典(哈希表)都可以.
- 画图演示:
  ![image](https://github.com/user-attachments/assets/27adac65-c099-48e4-a57c-d3753cfcd81d)
- 邻接表的问题:
  - 邻接表计算"出度"是比较简单的(出度: 指向别人的数量, 入度: 指向自己的数量)
  - 邻接表如果需要计算有向图的"入度", 那么是一件非常麻烦的事情.
  - 它必须构造一个"逆邻接表", 才能有效的计算"入度". 而邻接矩阵会非常简单.
## 三.图的封装
### 创建图类
- 创建一个Graph类
  ```
  function Graph() {
      // 属性
      this.vertexes = [] // 存储顶点
      this.adjList = new Dictionay() // 存储边, 邻接表的形式
      
      // 方法
  }
  ```
### 添加方法
- addVertex方法: 添加顶点
  ```
  // 添加方法
  Graph.prototype.addVertex = function (v) {
      this.vertexes.push(v)
      this.adjList.set(v, [])
  }
  ```
- addEdge方法: 添加边
  ```
  Graph.prototype.addEdge = function (v, w) {
      // 实现的是无向图
      this.adjList.get(v).push(w)
      this.adjList.get(w).push(v)
  }
  ```
### 测试代码
- 测试代码
  ```
  // 测试代码
  var graph = new Graph()
  
  // 添加顶点
  var myVertexes = ["A", "B", "C", "D", "E", "F", "G", "H", "I"]
  for (var i = 0; i < myVertexes.length; i++) {
      graph.addVertex(myVertexes[i])
  }
  
  // 添加边
  graph.addEdge('A', 'B');
  graph.addEdge('A', 'C');
  graph.addEdge('A', 'D');
  graph.addEdge('C', 'D');
  graph.addEdge('C', 'G');
  graph.addEdge('D', 'G');
  graph.addEdge('D', 'H');
  graph.addEdge('B', 'E');
  graph.addEdge('B', 'F');
  graph.addEdge('E', 'I');
  ```
- 效果如下:
  ![image](https://github.com/user-attachments/assets/249b00bc-2582-474f-a1d6-28e53a07c850)
### toString
- 实现Graph的toString方法
  ```
  Graph.prototype.toString = function () {
      var resultStr = ""
      // 遍历每一个顶点
      for (var i = 0; i < this.vertexes.length; i++) {
          // 每个顶点作为开头
          resultStr += this.vertexes[i] + "->"
          // 取出顶点的邻接表内容
          var adj = this.adjList.get(this.vertexes[i])
          // 遍历每个顶点的边, 即相邻顶点
          for (var j = 0; j < adj.length; j++) {
              resultStr += adj[j] + " "
          }
          // 遍历完一个顶点后换行
          resultStr += "\n"
      }
      return resultStr
  }
  ```
- 最终结果:
  ![image](https://github.com/user-attachments/assets/3cf90dfa-c313-4d21-b46e-11a9ea88a6f4)
